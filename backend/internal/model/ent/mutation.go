// Code generated by ent, DO NOT EDIT.

package ent

import (
	"agent-platform/internal/model/ent/agent"
	"agent-platform/internal/model/ent/conversation"
	"agent-platform/internal/model/ent/documentchunk"
	"agent-platform/internal/model/ent/knowledgebase"
	"agent-platform/internal/model/ent/predicate"
	"agent-platform/internal/model/ent/tool"
	"agent-platform/internal/model/ent/user"
	"agent-platform/internal/model/ent/workflow"
	"agent-platform/internal/model/ent/workflowexecution"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAgent             = "Agent"
	TypeConversation      = "Conversation"
	TypeDocumentChunk     = "DocumentChunk"
	TypeKnowledgeBase     = "KnowledgeBase"
	TypeTool              = "Tool"
	TypeUser              = "User"
	TypeWorkflow          = "Workflow"
	TypeWorkflowExecution = "WorkflowExecution"
)

// AgentMutation represents an operation that mutates the Agent nodes in the graph.
type AgentMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	name                  *string
	description           *string
	_type                 *string
	model_config          *map[string]interface{}
	tools                 *[]string
	appendtools           []string
	knowledge_bases       *[]string
	appendknowledge_bases []string
	prompt_template       *string
	parameters            *map[string]interface{}
	status                *string
	version               *string
	created_by            *string
	created_at            *time.Time
	updated_at            *time.Time
	tags                  *[]string
	appendtags            []string
	folder                *string
	is_public             *bool
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*Agent, error)
	predicates            []predicate.Agent
}

var _ ent.Mutation = (*AgentMutation)(nil)

// agentOption allows management of the mutation configuration using functional options.
type agentOption func(*AgentMutation)

// newAgentMutation creates new mutation for the Agent entity.
func newAgentMutation(c config, op Op, opts ...agentOption) *AgentMutation {
	m := &AgentMutation{
		config:        c,
		op:            op,
		typ:           TypeAgent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgentID sets the ID field of the mutation.
func withAgentID(id string) agentOption {
	return func(m *AgentMutation) {
		var (
			err   error
			once  sync.Once
			value *Agent
		)
		m.oldValue = func(ctx context.Context) (*Agent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Agent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgent sets the old Agent of the mutation.
func withAgent(node *Agent) agentOption {
	return func(m *AgentMutation) {
		m.oldValue = func(context.Context) (*Agent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Agent entities.
func (m *AgentMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AgentMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AgentMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Agent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AgentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AgentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AgentMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *AgentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AgentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AgentMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[agent.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AgentMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[agent.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AgentMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, agent.FieldDescription)
}

// SetType sets the "type" field.
func (m *AgentMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *AgentMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AgentMutation) ResetType() {
	m._type = nil
}

// SetModelConfig sets the "model_config" field.
func (m *AgentMutation) SetModelConfig(value map[string]interface{}) {
	m.model_config = &value
}

// ModelConfig returns the value of the "model_config" field in the mutation.
func (m *AgentMutation) ModelConfig() (r map[string]interface{}, exists bool) {
	v := m.model_config
	if v == nil {
		return
	}
	return *v, true
}

// OldModelConfig returns the old "model_config" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldModelConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelConfig: %w", err)
	}
	return oldValue.ModelConfig, nil
}

// ClearModelConfig clears the value of the "model_config" field.
func (m *AgentMutation) ClearModelConfig() {
	m.model_config = nil
	m.clearedFields[agent.FieldModelConfig] = struct{}{}
}

// ModelConfigCleared returns if the "model_config" field was cleared in this mutation.
func (m *AgentMutation) ModelConfigCleared() bool {
	_, ok := m.clearedFields[agent.FieldModelConfig]
	return ok
}

// ResetModelConfig resets all changes to the "model_config" field.
func (m *AgentMutation) ResetModelConfig() {
	m.model_config = nil
	delete(m.clearedFields, agent.FieldModelConfig)
}

// SetTools sets the "tools" field.
func (m *AgentMutation) SetTools(s []string) {
	m.tools = &s
	m.appendtools = nil
}

// Tools returns the value of the "tools" field in the mutation.
func (m *AgentMutation) Tools() (r []string, exists bool) {
	v := m.tools
	if v == nil {
		return
	}
	return *v, true
}

// OldTools returns the old "tools" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldTools(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTools is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTools requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTools: %w", err)
	}
	return oldValue.Tools, nil
}

// AppendTools adds s to the "tools" field.
func (m *AgentMutation) AppendTools(s []string) {
	m.appendtools = append(m.appendtools, s...)
}

// AppendedTools returns the list of values that were appended to the "tools" field in this mutation.
func (m *AgentMutation) AppendedTools() ([]string, bool) {
	if len(m.appendtools) == 0 {
		return nil, false
	}
	return m.appendtools, true
}

// ClearTools clears the value of the "tools" field.
func (m *AgentMutation) ClearTools() {
	m.tools = nil
	m.appendtools = nil
	m.clearedFields[agent.FieldTools] = struct{}{}
}

// ToolsCleared returns if the "tools" field was cleared in this mutation.
func (m *AgentMutation) ToolsCleared() bool {
	_, ok := m.clearedFields[agent.FieldTools]
	return ok
}

// ResetTools resets all changes to the "tools" field.
func (m *AgentMutation) ResetTools() {
	m.tools = nil
	m.appendtools = nil
	delete(m.clearedFields, agent.FieldTools)
}

// SetKnowledgeBases sets the "knowledge_bases" field.
func (m *AgentMutation) SetKnowledgeBases(s []string) {
	m.knowledge_bases = &s
	m.appendknowledge_bases = nil
}

// KnowledgeBases returns the value of the "knowledge_bases" field in the mutation.
func (m *AgentMutation) KnowledgeBases() (r []string, exists bool) {
	v := m.knowledge_bases
	if v == nil {
		return
	}
	return *v, true
}

// OldKnowledgeBases returns the old "knowledge_bases" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldKnowledgeBases(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKnowledgeBases is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKnowledgeBases requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKnowledgeBases: %w", err)
	}
	return oldValue.KnowledgeBases, nil
}

// AppendKnowledgeBases adds s to the "knowledge_bases" field.
func (m *AgentMutation) AppendKnowledgeBases(s []string) {
	m.appendknowledge_bases = append(m.appendknowledge_bases, s...)
}

// AppendedKnowledgeBases returns the list of values that were appended to the "knowledge_bases" field in this mutation.
func (m *AgentMutation) AppendedKnowledgeBases() ([]string, bool) {
	if len(m.appendknowledge_bases) == 0 {
		return nil, false
	}
	return m.appendknowledge_bases, true
}

// ClearKnowledgeBases clears the value of the "knowledge_bases" field.
func (m *AgentMutation) ClearKnowledgeBases() {
	m.knowledge_bases = nil
	m.appendknowledge_bases = nil
	m.clearedFields[agent.FieldKnowledgeBases] = struct{}{}
}

// KnowledgeBasesCleared returns if the "knowledge_bases" field was cleared in this mutation.
func (m *AgentMutation) KnowledgeBasesCleared() bool {
	_, ok := m.clearedFields[agent.FieldKnowledgeBases]
	return ok
}

// ResetKnowledgeBases resets all changes to the "knowledge_bases" field.
func (m *AgentMutation) ResetKnowledgeBases() {
	m.knowledge_bases = nil
	m.appendknowledge_bases = nil
	delete(m.clearedFields, agent.FieldKnowledgeBases)
}

// SetPromptTemplate sets the "prompt_template" field.
func (m *AgentMutation) SetPromptTemplate(s string) {
	m.prompt_template = &s
}

// PromptTemplate returns the value of the "prompt_template" field in the mutation.
func (m *AgentMutation) PromptTemplate() (r string, exists bool) {
	v := m.prompt_template
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptTemplate returns the old "prompt_template" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldPromptTemplate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptTemplate: %w", err)
	}
	return oldValue.PromptTemplate, nil
}

// ClearPromptTemplate clears the value of the "prompt_template" field.
func (m *AgentMutation) ClearPromptTemplate() {
	m.prompt_template = nil
	m.clearedFields[agent.FieldPromptTemplate] = struct{}{}
}

// PromptTemplateCleared returns if the "prompt_template" field was cleared in this mutation.
func (m *AgentMutation) PromptTemplateCleared() bool {
	_, ok := m.clearedFields[agent.FieldPromptTemplate]
	return ok
}

// ResetPromptTemplate resets all changes to the "prompt_template" field.
func (m *AgentMutation) ResetPromptTemplate() {
	m.prompt_template = nil
	delete(m.clearedFields, agent.FieldPromptTemplate)
}

// SetParameters sets the "parameters" field.
func (m *AgentMutation) SetParameters(value map[string]interface{}) {
	m.parameters = &value
}

// Parameters returns the value of the "parameters" field in the mutation.
func (m *AgentMutation) Parameters() (r map[string]interface{}, exists bool) {
	v := m.parameters
	if v == nil {
		return
	}
	return *v, true
}

// OldParameters returns the old "parameters" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldParameters(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParameters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParameters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParameters: %w", err)
	}
	return oldValue.Parameters, nil
}

// ClearParameters clears the value of the "parameters" field.
func (m *AgentMutation) ClearParameters() {
	m.parameters = nil
	m.clearedFields[agent.FieldParameters] = struct{}{}
}

// ParametersCleared returns if the "parameters" field was cleared in this mutation.
func (m *AgentMutation) ParametersCleared() bool {
	_, ok := m.clearedFields[agent.FieldParameters]
	return ok
}

// ResetParameters resets all changes to the "parameters" field.
func (m *AgentMutation) ResetParameters() {
	m.parameters = nil
	delete(m.clearedFields, agent.FieldParameters)
}

// SetStatus sets the "status" field.
func (m *AgentMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *AgentMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AgentMutation) ResetStatus() {
	m.status = nil
}

// SetVersion sets the "version" field.
func (m *AgentMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *AgentMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *AgentMutation) ResetVersion() {
	m.version = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *AgentMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AgentMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AgentMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AgentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AgentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AgentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AgentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AgentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AgentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTags sets the "tags" field.
func (m *AgentMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *AgentMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *AgentMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *AgentMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *AgentMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[agent.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *AgentMutation) TagsCleared() bool {
	_, ok := m.clearedFields[agent.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *AgentMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, agent.FieldTags)
}

// SetFolder sets the "folder" field.
func (m *AgentMutation) SetFolder(s string) {
	m.folder = &s
}

// Folder returns the value of the "folder" field in the mutation.
func (m *AgentMutation) Folder() (r string, exists bool) {
	v := m.folder
	if v == nil {
		return
	}
	return *v, true
}

// OldFolder returns the old "folder" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldFolder(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFolder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFolder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFolder: %w", err)
	}
	return oldValue.Folder, nil
}

// ClearFolder clears the value of the "folder" field.
func (m *AgentMutation) ClearFolder() {
	m.folder = nil
	m.clearedFields[agent.FieldFolder] = struct{}{}
}

// FolderCleared returns if the "folder" field was cleared in this mutation.
func (m *AgentMutation) FolderCleared() bool {
	_, ok := m.clearedFields[agent.FieldFolder]
	return ok
}

// ResetFolder resets all changes to the "folder" field.
func (m *AgentMutation) ResetFolder() {
	m.folder = nil
	delete(m.clearedFields, agent.FieldFolder)
}

// SetIsPublic sets the "is_public" field.
func (m *AgentMutation) SetIsPublic(b bool) {
	m.is_public = &b
}

// IsPublic returns the value of the "is_public" field in the mutation.
func (m *AgentMutation) IsPublic() (r bool, exists bool) {
	v := m.is_public
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublic returns the old "is_public" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldIsPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublic: %w", err)
	}
	return oldValue.IsPublic, nil
}

// ResetIsPublic resets all changes to the "is_public" field.
func (m *AgentMutation) ResetIsPublic() {
	m.is_public = nil
}

// Where appends a list predicates to the AgentMutation builder.
func (m *AgentMutation) Where(ps ...predicate.Agent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AgentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AgentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Agent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AgentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AgentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Agent).
func (m *AgentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AgentMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.name != nil {
		fields = append(fields, agent.FieldName)
	}
	if m.description != nil {
		fields = append(fields, agent.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, agent.FieldType)
	}
	if m.model_config != nil {
		fields = append(fields, agent.FieldModelConfig)
	}
	if m.tools != nil {
		fields = append(fields, agent.FieldTools)
	}
	if m.knowledge_bases != nil {
		fields = append(fields, agent.FieldKnowledgeBases)
	}
	if m.prompt_template != nil {
		fields = append(fields, agent.FieldPromptTemplate)
	}
	if m.parameters != nil {
		fields = append(fields, agent.FieldParameters)
	}
	if m.status != nil {
		fields = append(fields, agent.FieldStatus)
	}
	if m.version != nil {
		fields = append(fields, agent.FieldVersion)
	}
	if m.created_by != nil {
		fields = append(fields, agent.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, agent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, agent.FieldUpdatedAt)
	}
	if m.tags != nil {
		fields = append(fields, agent.FieldTags)
	}
	if m.folder != nil {
		fields = append(fields, agent.FieldFolder)
	}
	if m.is_public != nil {
		fields = append(fields, agent.FieldIsPublic)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AgentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case agent.FieldName:
		return m.Name()
	case agent.FieldDescription:
		return m.Description()
	case agent.FieldType:
		return m.GetType()
	case agent.FieldModelConfig:
		return m.ModelConfig()
	case agent.FieldTools:
		return m.Tools()
	case agent.FieldKnowledgeBases:
		return m.KnowledgeBases()
	case agent.FieldPromptTemplate:
		return m.PromptTemplate()
	case agent.FieldParameters:
		return m.Parameters()
	case agent.FieldStatus:
		return m.Status()
	case agent.FieldVersion:
		return m.Version()
	case agent.FieldCreatedBy:
		return m.CreatedBy()
	case agent.FieldCreatedAt:
		return m.CreatedAt()
	case agent.FieldUpdatedAt:
		return m.UpdatedAt()
	case agent.FieldTags:
		return m.Tags()
	case agent.FieldFolder:
		return m.Folder()
	case agent.FieldIsPublic:
		return m.IsPublic()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AgentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case agent.FieldName:
		return m.OldName(ctx)
	case agent.FieldDescription:
		return m.OldDescription(ctx)
	case agent.FieldType:
		return m.OldType(ctx)
	case agent.FieldModelConfig:
		return m.OldModelConfig(ctx)
	case agent.FieldTools:
		return m.OldTools(ctx)
	case agent.FieldKnowledgeBases:
		return m.OldKnowledgeBases(ctx)
	case agent.FieldPromptTemplate:
		return m.OldPromptTemplate(ctx)
	case agent.FieldParameters:
		return m.OldParameters(ctx)
	case agent.FieldStatus:
		return m.OldStatus(ctx)
	case agent.FieldVersion:
		return m.OldVersion(ctx)
	case agent.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case agent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case agent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case agent.FieldTags:
		return m.OldTags(ctx)
	case agent.FieldFolder:
		return m.OldFolder(ctx)
	case agent.FieldIsPublic:
		return m.OldIsPublic(ctx)
	}
	return nil, fmt.Errorf("unknown Agent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case agent.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case agent.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case agent.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case agent.FieldModelConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelConfig(v)
		return nil
	case agent.FieldTools:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTools(v)
		return nil
	case agent.FieldKnowledgeBases:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKnowledgeBases(v)
		return nil
	case agent.FieldPromptTemplate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptTemplate(v)
		return nil
	case agent.FieldParameters:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParameters(v)
		return nil
	case agent.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case agent.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case agent.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case agent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case agent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case agent.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case agent.FieldFolder:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFolder(v)
		return nil
	case agent.FieldIsPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublic(v)
		return nil
	}
	return fmt.Errorf("unknown Agent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AgentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AgentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Agent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AgentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(agent.FieldDescription) {
		fields = append(fields, agent.FieldDescription)
	}
	if m.FieldCleared(agent.FieldModelConfig) {
		fields = append(fields, agent.FieldModelConfig)
	}
	if m.FieldCleared(agent.FieldTools) {
		fields = append(fields, agent.FieldTools)
	}
	if m.FieldCleared(agent.FieldKnowledgeBases) {
		fields = append(fields, agent.FieldKnowledgeBases)
	}
	if m.FieldCleared(agent.FieldPromptTemplate) {
		fields = append(fields, agent.FieldPromptTemplate)
	}
	if m.FieldCleared(agent.FieldParameters) {
		fields = append(fields, agent.FieldParameters)
	}
	if m.FieldCleared(agent.FieldTags) {
		fields = append(fields, agent.FieldTags)
	}
	if m.FieldCleared(agent.FieldFolder) {
		fields = append(fields, agent.FieldFolder)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AgentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgentMutation) ClearField(name string) error {
	switch name {
	case agent.FieldDescription:
		m.ClearDescription()
		return nil
	case agent.FieldModelConfig:
		m.ClearModelConfig()
		return nil
	case agent.FieldTools:
		m.ClearTools()
		return nil
	case agent.FieldKnowledgeBases:
		m.ClearKnowledgeBases()
		return nil
	case agent.FieldPromptTemplate:
		m.ClearPromptTemplate()
		return nil
	case agent.FieldParameters:
		m.ClearParameters()
		return nil
	case agent.FieldTags:
		m.ClearTags()
		return nil
	case agent.FieldFolder:
		m.ClearFolder()
		return nil
	}
	return fmt.Errorf("unknown Agent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AgentMutation) ResetField(name string) error {
	switch name {
	case agent.FieldName:
		m.ResetName()
		return nil
	case agent.FieldDescription:
		m.ResetDescription()
		return nil
	case agent.FieldType:
		m.ResetType()
		return nil
	case agent.FieldModelConfig:
		m.ResetModelConfig()
		return nil
	case agent.FieldTools:
		m.ResetTools()
		return nil
	case agent.FieldKnowledgeBases:
		m.ResetKnowledgeBases()
		return nil
	case agent.FieldPromptTemplate:
		m.ResetPromptTemplate()
		return nil
	case agent.FieldParameters:
		m.ResetParameters()
		return nil
	case agent.FieldStatus:
		m.ResetStatus()
		return nil
	case agent.FieldVersion:
		m.ResetVersion()
		return nil
	case agent.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case agent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case agent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case agent.FieldTags:
		m.ResetTags()
		return nil
	case agent.FieldFolder:
		m.ResetFolder()
		return nil
	case agent.FieldIsPublic:
		m.ResetIsPublic()
		return nil
	}
	return fmt.Errorf("unknown Agent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AgentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AgentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AgentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AgentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AgentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AgentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AgentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Agent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AgentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Agent edge %s", name)
}

// ConversationMutation represents an operation that mutates the Conversation nodes in the graph.
type ConversationMutation struct {
	config
	op              Op
	typ             string
	id              *string
	agent_id        *string
	user_id         *string
	title           *string
	messages        *[]interface{}
	appendmessages  []interface{}
	context         *map[string]interface{}
	metadata        *map[string]interface{}
	status          *string
	created_at      *time.Time
	updated_at      *time.Time
	last_message_at *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Conversation, error)
	predicates      []predicate.Conversation
}

var _ ent.Mutation = (*ConversationMutation)(nil)

// conversationOption allows management of the mutation configuration using functional options.
type conversationOption func(*ConversationMutation)

// newConversationMutation creates new mutation for the Conversation entity.
func newConversationMutation(c config, op Op, opts ...conversationOption) *ConversationMutation {
	m := &ConversationMutation{
		config:        c,
		op:            op,
		typ:           TypeConversation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConversationID sets the ID field of the mutation.
func withConversationID(id string) conversationOption {
	return func(m *ConversationMutation) {
		var (
			err   error
			once  sync.Once
			value *Conversation
		)
		m.oldValue = func(ctx context.Context) (*Conversation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Conversation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConversation sets the old Conversation of the mutation.
func withConversation(node *Conversation) conversationOption {
	return func(m *ConversationMutation) {
		m.oldValue = func(context.Context) (*Conversation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConversationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConversationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Conversation entities.
func (m *ConversationMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConversationMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConversationMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Conversation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAgentID sets the "agent_id" field.
func (m *ConversationMutation) SetAgentID(s string) {
	m.agent_id = &s
}

// AgentID returns the value of the "agent_id" field in the mutation.
func (m *ConversationMutation) AgentID() (r string, exists bool) {
	v := m.agent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentID returns the old "agent_id" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldAgentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentID: %w", err)
	}
	return oldValue.AgentID, nil
}

// ResetAgentID resets all changes to the "agent_id" field.
func (m *ConversationMutation) ResetAgentID() {
	m.agent_id = nil
}

// SetUserID sets the "user_id" field.
func (m *ConversationMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ConversationMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ConversationMutation) ResetUserID() {
	m.user_id = nil
}

// SetTitle sets the "title" field.
func (m *ConversationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ConversationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *ConversationMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[conversation.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *ConversationMutation) TitleCleared() bool {
	_, ok := m.clearedFields[conversation.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *ConversationMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, conversation.FieldTitle)
}

// SetMessages sets the "messages" field.
func (m *ConversationMutation) SetMessages(i []interface{}) {
	m.messages = &i
	m.appendmessages = nil
}

// Messages returns the value of the "messages" field in the mutation.
func (m *ConversationMutation) Messages() (r []interface{}, exists bool) {
	v := m.messages
	if v == nil {
		return
	}
	return *v, true
}

// OldMessages returns the old "messages" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldMessages(ctx context.Context) (v []interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessages: %w", err)
	}
	return oldValue.Messages, nil
}

// AppendMessages adds i to the "messages" field.
func (m *ConversationMutation) AppendMessages(i []interface{}) {
	m.appendmessages = append(m.appendmessages, i...)
}

// AppendedMessages returns the list of values that were appended to the "messages" field in this mutation.
func (m *ConversationMutation) AppendedMessages() ([]interface{}, bool) {
	if len(m.appendmessages) == 0 {
		return nil, false
	}
	return m.appendmessages, true
}

// ClearMessages clears the value of the "messages" field.
func (m *ConversationMutation) ClearMessages() {
	m.messages = nil
	m.appendmessages = nil
	m.clearedFields[conversation.FieldMessages] = struct{}{}
}

// MessagesCleared returns if the "messages" field was cleared in this mutation.
func (m *ConversationMutation) MessagesCleared() bool {
	_, ok := m.clearedFields[conversation.FieldMessages]
	return ok
}

// ResetMessages resets all changes to the "messages" field.
func (m *ConversationMutation) ResetMessages() {
	m.messages = nil
	m.appendmessages = nil
	delete(m.clearedFields, conversation.FieldMessages)
}

// SetContext sets the "context" field.
func (m *ConversationMutation) SetContext(value map[string]interface{}) {
	m.context = &value
}

// Context returns the value of the "context" field in the mutation.
func (m *ConversationMutation) Context() (r map[string]interface{}, exists bool) {
	v := m.context
	if v == nil {
		return
	}
	return *v, true
}

// OldContext returns the old "context" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldContext(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContext is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContext requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContext: %w", err)
	}
	return oldValue.Context, nil
}

// ClearContext clears the value of the "context" field.
func (m *ConversationMutation) ClearContext() {
	m.context = nil
	m.clearedFields[conversation.FieldContext] = struct{}{}
}

// ContextCleared returns if the "context" field was cleared in this mutation.
func (m *ConversationMutation) ContextCleared() bool {
	_, ok := m.clearedFields[conversation.FieldContext]
	return ok
}

// ResetContext resets all changes to the "context" field.
func (m *ConversationMutation) ResetContext() {
	m.context = nil
	delete(m.clearedFields, conversation.FieldContext)
}

// SetMetadata sets the "metadata" field.
func (m *ConversationMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *ConversationMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *ConversationMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[conversation.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *ConversationMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[conversation.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *ConversationMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, conversation.FieldMetadata)
}

// SetStatus sets the "status" field.
func (m *ConversationMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ConversationMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ConversationMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ConversationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ConversationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ConversationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ConversationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ConversationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ConversationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLastMessageAt sets the "last_message_at" field.
func (m *ConversationMutation) SetLastMessageAt(t time.Time) {
	m.last_message_at = &t
}

// LastMessageAt returns the value of the "last_message_at" field in the mutation.
func (m *ConversationMutation) LastMessageAt() (r time.Time, exists bool) {
	v := m.last_message_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastMessageAt returns the old "last_message_at" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldLastMessageAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastMessageAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastMessageAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastMessageAt: %w", err)
	}
	return oldValue.LastMessageAt, nil
}

// ClearLastMessageAt clears the value of the "last_message_at" field.
func (m *ConversationMutation) ClearLastMessageAt() {
	m.last_message_at = nil
	m.clearedFields[conversation.FieldLastMessageAt] = struct{}{}
}

// LastMessageAtCleared returns if the "last_message_at" field was cleared in this mutation.
func (m *ConversationMutation) LastMessageAtCleared() bool {
	_, ok := m.clearedFields[conversation.FieldLastMessageAt]
	return ok
}

// ResetLastMessageAt resets all changes to the "last_message_at" field.
func (m *ConversationMutation) ResetLastMessageAt() {
	m.last_message_at = nil
	delete(m.clearedFields, conversation.FieldLastMessageAt)
}

// Where appends a list predicates to the ConversationMutation builder.
func (m *ConversationMutation) Where(ps ...predicate.Conversation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConversationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConversationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Conversation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConversationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConversationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Conversation).
func (m *ConversationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConversationMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.agent_id != nil {
		fields = append(fields, conversation.FieldAgentID)
	}
	if m.user_id != nil {
		fields = append(fields, conversation.FieldUserID)
	}
	if m.title != nil {
		fields = append(fields, conversation.FieldTitle)
	}
	if m.messages != nil {
		fields = append(fields, conversation.FieldMessages)
	}
	if m.context != nil {
		fields = append(fields, conversation.FieldContext)
	}
	if m.metadata != nil {
		fields = append(fields, conversation.FieldMetadata)
	}
	if m.status != nil {
		fields = append(fields, conversation.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, conversation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, conversation.FieldUpdatedAt)
	}
	if m.last_message_at != nil {
		fields = append(fields, conversation.FieldLastMessageAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConversationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case conversation.FieldAgentID:
		return m.AgentID()
	case conversation.FieldUserID:
		return m.UserID()
	case conversation.FieldTitle:
		return m.Title()
	case conversation.FieldMessages:
		return m.Messages()
	case conversation.FieldContext:
		return m.Context()
	case conversation.FieldMetadata:
		return m.Metadata()
	case conversation.FieldStatus:
		return m.Status()
	case conversation.FieldCreatedAt:
		return m.CreatedAt()
	case conversation.FieldUpdatedAt:
		return m.UpdatedAt()
	case conversation.FieldLastMessageAt:
		return m.LastMessageAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConversationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case conversation.FieldAgentID:
		return m.OldAgentID(ctx)
	case conversation.FieldUserID:
		return m.OldUserID(ctx)
	case conversation.FieldTitle:
		return m.OldTitle(ctx)
	case conversation.FieldMessages:
		return m.OldMessages(ctx)
	case conversation.FieldContext:
		return m.OldContext(ctx)
	case conversation.FieldMetadata:
		return m.OldMetadata(ctx)
	case conversation.FieldStatus:
		return m.OldStatus(ctx)
	case conversation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case conversation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case conversation.FieldLastMessageAt:
		return m.OldLastMessageAt(ctx)
	}
	return nil, fmt.Errorf("unknown Conversation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConversationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case conversation.FieldAgentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentID(v)
		return nil
	case conversation.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case conversation.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case conversation.FieldMessages:
		v, ok := value.([]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessages(v)
		return nil
	case conversation.FieldContext:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContext(v)
		return nil
	case conversation.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case conversation.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case conversation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case conversation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case conversation.FieldLastMessageAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastMessageAt(v)
		return nil
	}
	return fmt.Errorf("unknown Conversation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConversationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConversationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConversationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Conversation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConversationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(conversation.FieldTitle) {
		fields = append(fields, conversation.FieldTitle)
	}
	if m.FieldCleared(conversation.FieldMessages) {
		fields = append(fields, conversation.FieldMessages)
	}
	if m.FieldCleared(conversation.FieldContext) {
		fields = append(fields, conversation.FieldContext)
	}
	if m.FieldCleared(conversation.FieldMetadata) {
		fields = append(fields, conversation.FieldMetadata)
	}
	if m.FieldCleared(conversation.FieldLastMessageAt) {
		fields = append(fields, conversation.FieldLastMessageAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConversationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConversationMutation) ClearField(name string) error {
	switch name {
	case conversation.FieldTitle:
		m.ClearTitle()
		return nil
	case conversation.FieldMessages:
		m.ClearMessages()
		return nil
	case conversation.FieldContext:
		m.ClearContext()
		return nil
	case conversation.FieldMetadata:
		m.ClearMetadata()
		return nil
	case conversation.FieldLastMessageAt:
		m.ClearLastMessageAt()
		return nil
	}
	return fmt.Errorf("unknown Conversation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConversationMutation) ResetField(name string) error {
	switch name {
	case conversation.FieldAgentID:
		m.ResetAgentID()
		return nil
	case conversation.FieldUserID:
		m.ResetUserID()
		return nil
	case conversation.FieldTitle:
		m.ResetTitle()
		return nil
	case conversation.FieldMessages:
		m.ResetMessages()
		return nil
	case conversation.FieldContext:
		m.ResetContext()
		return nil
	case conversation.FieldMetadata:
		m.ResetMetadata()
		return nil
	case conversation.FieldStatus:
		m.ResetStatus()
		return nil
	case conversation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case conversation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case conversation.FieldLastMessageAt:
		m.ResetLastMessageAt()
		return nil
	}
	return fmt.Errorf("unknown Conversation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConversationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConversationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConversationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConversationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConversationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConversationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConversationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Conversation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConversationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Conversation edge %s", name)
}

// DocumentChunkMutation represents an operation that mutates the DocumentChunk nodes in the graph.
type DocumentChunkMutation struct {
	config
	op                Op
	typ               string
	id                *string
	knowledge_base_id *string
	document_id       *string
	chunk_index       *int
	addchunk_index    *int
	content           *string
	embedding         *[]float32
	appendembedding   []float32
	metadata          *map[string]interface{}
	created_at        *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*DocumentChunk, error)
	predicates        []predicate.DocumentChunk
}

var _ ent.Mutation = (*DocumentChunkMutation)(nil)

// documentchunkOption allows management of the mutation configuration using functional options.
type documentchunkOption func(*DocumentChunkMutation)

// newDocumentChunkMutation creates new mutation for the DocumentChunk entity.
func newDocumentChunkMutation(c config, op Op, opts ...documentchunkOption) *DocumentChunkMutation {
	m := &DocumentChunkMutation{
		config:        c,
		op:            op,
		typ:           TypeDocumentChunk,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDocumentChunkID sets the ID field of the mutation.
func withDocumentChunkID(id string) documentchunkOption {
	return func(m *DocumentChunkMutation) {
		var (
			err   error
			once  sync.Once
			value *DocumentChunk
		)
		m.oldValue = func(ctx context.Context) (*DocumentChunk, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DocumentChunk.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDocumentChunk sets the old DocumentChunk of the mutation.
func withDocumentChunk(node *DocumentChunk) documentchunkOption {
	return func(m *DocumentChunkMutation) {
		m.oldValue = func(context.Context) (*DocumentChunk, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DocumentChunkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DocumentChunkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DocumentChunk entities.
func (m *DocumentChunkMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DocumentChunkMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DocumentChunkMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DocumentChunk.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKnowledgeBaseID sets the "knowledge_base_id" field.
func (m *DocumentChunkMutation) SetKnowledgeBaseID(s string) {
	m.knowledge_base_id = &s
}

// KnowledgeBaseID returns the value of the "knowledge_base_id" field in the mutation.
func (m *DocumentChunkMutation) KnowledgeBaseID() (r string, exists bool) {
	v := m.knowledge_base_id
	if v == nil {
		return
	}
	return *v, true
}

// OldKnowledgeBaseID returns the old "knowledge_base_id" field's value of the DocumentChunk entity.
// If the DocumentChunk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentChunkMutation) OldKnowledgeBaseID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKnowledgeBaseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKnowledgeBaseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKnowledgeBaseID: %w", err)
	}
	return oldValue.KnowledgeBaseID, nil
}

// ResetKnowledgeBaseID resets all changes to the "knowledge_base_id" field.
func (m *DocumentChunkMutation) ResetKnowledgeBaseID() {
	m.knowledge_base_id = nil
}

// SetDocumentID sets the "document_id" field.
func (m *DocumentChunkMutation) SetDocumentID(s string) {
	m.document_id = &s
}

// DocumentID returns the value of the "document_id" field in the mutation.
func (m *DocumentChunkMutation) DocumentID() (r string, exists bool) {
	v := m.document_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentID returns the old "document_id" field's value of the DocumentChunk entity.
// If the DocumentChunk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentChunkMutation) OldDocumentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentID: %w", err)
	}
	return oldValue.DocumentID, nil
}

// ResetDocumentID resets all changes to the "document_id" field.
func (m *DocumentChunkMutation) ResetDocumentID() {
	m.document_id = nil
}

// SetChunkIndex sets the "chunk_index" field.
func (m *DocumentChunkMutation) SetChunkIndex(i int) {
	m.chunk_index = &i
	m.addchunk_index = nil
}

// ChunkIndex returns the value of the "chunk_index" field in the mutation.
func (m *DocumentChunkMutation) ChunkIndex() (r int, exists bool) {
	v := m.chunk_index
	if v == nil {
		return
	}
	return *v, true
}

// OldChunkIndex returns the old "chunk_index" field's value of the DocumentChunk entity.
// If the DocumentChunk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentChunkMutation) OldChunkIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChunkIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChunkIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChunkIndex: %w", err)
	}
	return oldValue.ChunkIndex, nil
}

// AddChunkIndex adds i to the "chunk_index" field.
func (m *DocumentChunkMutation) AddChunkIndex(i int) {
	if m.addchunk_index != nil {
		*m.addchunk_index += i
	} else {
		m.addchunk_index = &i
	}
}

// AddedChunkIndex returns the value that was added to the "chunk_index" field in this mutation.
func (m *DocumentChunkMutation) AddedChunkIndex() (r int, exists bool) {
	v := m.addchunk_index
	if v == nil {
		return
	}
	return *v, true
}

// ResetChunkIndex resets all changes to the "chunk_index" field.
func (m *DocumentChunkMutation) ResetChunkIndex() {
	m.chunk_index = nil
	m.addchunk_index = nil
}

// SetContent sets the "content" field.
func (m *DocumentChunkMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *DocumentChunkMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the DocumentChunk entity.
// If the DocumentChunk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentChunkMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *DocumentChunkMutation) ResetContent() {
	m.content = nil
}

// SetEmbedding sets the "embedding" field.
func (m *DocumentChunkMutation) SetEmbedding(f []float32) {
	m.embedding = &f
	m.appendembedding = nil
}

// Embedding returns the value of the "embedding" field in the mutation.
func (m *DocumentChunkMutation) Embedding() (r []float32, exists bool) {
	v := m.embedding
	if v == nil {
		return
	}
	return *v, true
}

// OldEmbedding returns the old "embedding" field's value of the DocumentChunk entity.
// If the DocumentChunk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentChunkMutation) OldEmbedding(ctx context.Context) (v []float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmbedding is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmbedding requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmbedding: %w", err)
	}
	return oldValue.Embedding, nil
}

// AppendEmbedding adds f to the "embedding" field.
func (m *DocumentChunkMutation) AppendEmbedding(f []float32) {
	m.appendembedding = append(m.appendembedding, f...)
}

// AppendedEmbedding returns the list of values that were appended to the "embedding" field in this mutation.
func (m *DocumentChunkMutation) AppendedEmbedding() ([]float32, bool) {
	if len(m.appendembedding) == 0 {
		return nil, false
	}
	return m.appendembedding, true
}

// ClearEmbedding clears the value of the "embedding" field.
func (m *DocumentChunkMutation) ClearEmbedding() {
	m.embedding = nil
	m.appendembedding = nil
	m.clearedFields[documentchunk.FieldEmbedding] = struct{}{}
}

// EmbeddingCleared returns if the "embedding" field was cleared in this mutation.
func (m *DocumentChunkMutation) EmbeddingCleared() bool {
	_, ok := m.clearedFields[documentchunk.FieldEmbedding]
	return ok
}

// ResetEmbedding resets all changes to the "embedding" field.
func (m *DocumentChunkMutation) ResetEmbedding() {
	m.embedding = nil
	m.appendembedding = nil
	delete(m.clearedFields, documentchunk.FieldEmbedding)
}

// SetMetadata sets the "metadata" field.
func (m *DocumentChunkMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *DocumentChunkMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the DocumentChunk entity.
// If the DocumentChunk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentChunkMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *DocumentChunkMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[documentchunk.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *DocumentChunkMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[documentchunk.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *DocumentChunkMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, documentchunk.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *DocumentChunkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DocumentChunkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DocumentChunk entity.
// If the DocumentChunk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentChunkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DocumentChunkMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the DocumentChunkMutation builder.
func (m *DocumentChunkMutation) Where(ps ...predicate.DocumentChunk) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DocumentChunkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DocumentChunkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DocumentChunk, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DocumentChunkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DocumentChunkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DocumentChunk).
func (m *DocumentChunkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DocumentChunkMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.knowledge_base_id != nil {
		fields = append(fields, documentchunk.FieldKnowledgeBaseID)
	}
	if m.document_id != nil {
		fields = append(fields, documentchunk.FieldDocumentID)
	}
	if m.chunk_index != nil {
		fields = append(fields, documentchunk.FieldChunkIndex)
	}
	if m.content != nil {
		fields = append(fields, documentchunk.FieldContent)
	}
	if m.embedding != nil {
		fields = append(fields, documentchunk.FieldEmbedding)
	}
	if m.metadata != nil {
		fields = append(fields, documentchunk.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, documentchunk.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DocumentChunkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case documentchunk.FieldKnowledgeBaseID:
		return m.KnowledgeBaseID()
	case documentchunk.FieldDocumentID:
		return m.DocumentID()
	case documentchunk.FieldChunkIndex:
		return m.ChunkIndex()
	case documentchunk.FieldContent:
		return m.Content()
	case documentchunk.FieldEmbedding:
		return m.Embedding()
	case documentchunk.FieldMetadata:
		return m.Metadata()
	case documentchunk.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DocumentChunkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case documentchunk.FieldKnowledgeBaseID:
		return m.OldKnowledgeBaseID(ctx)
	case documentchunk.FieldDocumentID:
		return m.OldDocumentID(ctx)
	case documentchunk.FieldChunkIndex:
		return m.OldChunkIndex(ctx)
	case documentchunk.FieldContent:
		return m.OldContent(ctx)
	case documentchunk.FieldEmbedding:
		return m.OldEmbedding(ctx)
	case documentchunk.FieldMetadata:
		return m.OldMetadata(ctx)
	case documentchunk.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown DocumentChunk field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentChunkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case documentchunk.FieldKnowledgeBaseID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKnowledgeBaseID(v)
		return nil
	case documentchunk.FieldDocumentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentID(v)
		return nil
	case documentchunk.FieldChunkIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChunkIndex(v)
		return nil
	case documentchunk.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case documentchunk.FieldEmbedding:
		v, ok := value.([]float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmbedding(v)
		return nil
	case documentchunk.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case documentchunk.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown DocumentChunk field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DocumentChunkMutation) AddedFields() []string {
	var fields []string
	if m.addchunk_index != nil {
		fields = append(fields, documentchunk.FieldChunkIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DocumentChunkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case documentchunk.FieldChunkIndex:
		return m.AddedChunkIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentChunkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case documentchunk.FieldChunkIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChunkIndex(v)
		return nil
	}
	return fmt.Errorf("unknown DocumentChunk numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DocumentChunkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(documentchunk.FieldEmbedding) {
		fields = append(fields, documentchunk.FieldEmbedding)
	}
	if m.FieldCleared(documentchunk.FieldMetadata) {
		fields = append(fields, documentchunk.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DocumentChunkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DocumentChunkMutation) ClearField(name string) error {
	switch name {
	case documentchunk.FieldEmbedding:
		m.ClearEmbedding()
		return nil
	case documentchunk.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown DocumentChunk nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DocumentChunkMutation) ResetField(name string) error {
	switch name {
	case documentchunk.FieldKnowledgeBaseID:
		m.ResetKnowledgeBaseID()
		return nil
	case documentchunk.FieldDocumentID:
		m.ResetDocumentID()
		return nil
	case documentchunk.FieldChunkIndex:
		m.ResetChunkIndex()
		return nil
	case documentchunk.FieldContent:
		m.ResetContent()
		return nil
	case documentchunk.FieldEmbedding:
		m.ResetEmbedding()
		return nil
	case documentchunk.FieldMetadata:
		m.ResetMetadata()
		return nil
	case documentchunk.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown DocumentChunk field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DocumentChunkMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DocumentChunkMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DocumentChunkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DocumentChunkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DocumentChunkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DocumentChunkMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DocumentChunkMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DocumentChunk unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DocumentChunkMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DocumentChunk edge %s", name)
}

// KnowledgeBaseMutation represents an operation that mutates the KnowledgeBase nodes in the graph.
type KnowledgeBaseMutation struct {
	config
	op                Op
	typ               string
	id                *string
	name              *string
	description       *string
	_type             *string
	embedding_model   *string
	chunk_config      *map[string]interface{}
	documents         *[]interface{}
	appenddocuments   []interface{}
	metadata          *map[string]interface{}
	created_by        *string
	created_at        *time.Time
	updated_at        *time.Time
	document_count    *int
	adddocument_count *int
	vector_count      *int
	addvector_count   *int
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*KnowledgeBase, error)
	predicates        []predicate.KnowledgeBase
}

var _ ent.Mutation = (*KnowledgeBaseMutation)(nil)

// knowledgebaseOption allows management of the mutation configuration using functional options.
type knowledgebaseOption func(*KnowledgeBaseMutation)

// newKnowledgeBaseMutation creates new mutation for the KnowledgeBase entity.
func newKnowledgeBaseMutation(c config, op Op, opts ...knowledgebaseOption) *KnowledgeBaseMutation {
	m := &KnowledgeBaseMutation{
		config:        c,
		op:            op,
		typ:           TypeKnowledgeBase,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKnowledgeBaseID sets the ID field of the mutation.
func withKnowledgeBaseID(id string) knowledgebaseOption {
	return func(m *KnowledgeBaseMutation) {
		var (
			err   error
			once  sync.Once
			value *KnowledgeBase
		)
		m.oldValue = func(ctx context.Context) (*KnowledgeBase, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KnowledgeBase.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKnowledgeBase sets the old KnowledgeBase of the mutation.
func withKnowledgeBase(node *KnowledgeBase) knowledgebaseOption {
	return func(m *KnowledgeBaseMutation) {
		m.oldValue = func(context.Context) (*KnowledgeBase, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KnowledgeBaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KnowledgeBaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of KnowledgeBase entities.
func (m *KnowledgeBaseMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *KnowledgeBaseMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *KnowledgeBaseMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().KnowledgeBase.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *KnowledgeBaseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *KnowledgeBaseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the KnowledgeBase entity.
// If the KnowledgeBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeBaseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *KnowledgeBaseMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *KnowledgeBaseMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *KnowledgeBaseMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the KnowledgeBase entity.
// If the KnowledgeBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeBaseMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *KnowledgeBaseMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[knowledgebase.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *KnowledgeBaseMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[knowledgebase.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *KnowledgeBaseMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, knowledgebase.FieldDescription)
}

// SetType sets the "type" field.
func (m *KnowledgeBaseMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *KnowledgeBaseMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the KnowledgeBase entity.
// If the KnowledgeBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeBaseMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *KnowledgeBaseMutation) ResetType() {
	m._type = nil
}

// SetEmbeddingModel sets the "embedding_model" field.
func (m *KnowledgeBaseMutation) SetEmbeddingModel(s string) {
	m.embedding_model = &s
}

// EmbeddingModel returns the value of the "embedding_model" field in the mutation.
func (m *KnowledgeBaseMutation) EmbeddingModel() (r string, exists bool) {
	v := m.embedding_model
	if v == nil {
		return
	}
	return *v, true
}

// OldEmbeddingModel returns the old "embedding_model" field's value of the KnowledgeBase entity.
// If the KnowledgeBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeBaseMutation) OldEmbeddingModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmbeddingModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmbeddingModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmbeddingModel: %w", err)
	}
	return oldValue.EmbeddingModel, nil
}

// ResetEmbeddingModel resets all changes to the "embedding_model" field.
func (m *KnowledgeBaseMutation) ResetEmbeddingModel() {
	m.embedding_model = nil
}

// SetChunkConfig sets the "chunk_config" field.
func (m *KnowledgeBaseMutation) SetChunkConfig(value map[string]interface{}) {
	m.chunk_config = &value
}

// ChunkConfig returns the value of the "chunk_config" field in the mutation.
func (m *KnowledgeBaseMutation) ChunkConfig() (r map[string]interface{}, exists bool) {
	v := m.chunk_config
	if v == nil {
		return
	}
	return *v, true
}

// OldChunkConfig returns the old "chunk_config" field's value of the KnowledgeBase entity.
// If the KnowledgeBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeBaseMutation) OldChunkConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChunkConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChunkConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChunkConfig: %w", err)
	}
	return oldValue.ChunkConfig, nil
}

// ClearChunkConfig clears the value of the "chunk_config" field.
func (m *KnowledgeBaseMutation) ClearChunkConfig() {
	m.chunk_config = nil
	m.clearedFields[knowledgebase.FieldChunkConfig] = struct{}{}
}

// ChunkConfigCleared returns if the "chunk_config" field was cleared in this mutation.
func (m *KnowledgeBaseMutation) ChunkConfigCleared() bool {
	_, ok := m.clearedFields[knowledgebase.FieldChunkConfig]
	return ok
}

// ResetChunkConfig resets all changes to the "chunk_config" field.
func (m *KnowledgeBaseMutation) ResetChunkConfig() {
	m.chunk_config = nil
	delete(m.clearedFields, knowledgebase.FieldChunkConfig)
}

// SetDocuments sets the "documents" field.
func (m *KnowledgeBaseMutation) SetDocuments(i []interface{}) {
	m.documents = &i
	m.appenddocuments = nil
}

// Documents returns the value of the "documents" field in the mutation.
func (m *KnowledgeBaseMutation) Documents() (r []interface{}, exists bool) {
	v := m.documents
	if v == nil {
		return
	}
	return *v, true
}

// OldDocuments returns the old "documents" field's value of the KnowledgeBase entity.
// If the KnowledgeBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeBaseMutation) OldDocuments(ctx context.Context) (v []interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocuments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocuments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocuments: %w", err)
	}
	return oldValue.Documents, nil
}

// AppendDocuments adds i to the "documents" field.
func (m *KnowledgeBaseMutation) AppendDocuments(i []interface{}) {
	m.appenddocuments = append(m.appenddocuments, i...)
}

// AppendedDocuments returns the list of values that were appended to the "documents" field in this mutation.
func (m *KnowledgeBaseMutation) AppendedDocuments() ([]interface{}, bool) {
	if len(m.appenddocuments) == 0 {
		return nil, false
	}
	return m.appenddocuments, true
}

// ClearDocuments clears the value of the "documents" field.
func (m *KnowledgeBaseMutation) ClearDocuments() {
	m.documents = nil
	m.appenddocuments = nil
	m.clearedFields[knowledgebase.FieldDocuments] = struct{}{}
}

// DocumentsCleared returns if the "documents" field was cleared in this mutation.
func (m *KnowledgeBaseMutation) DocumentsCleared() bool {
	_, ok := m.clearedFields[knowledgebase.FieldDocuments]
	return ok
}

// ResetDocuments resets all changes to the "documents" field.
func (m *KnowledgeBaseMutation) ResetDocuments() {
	m.documents = nil
	m.appenddocuments = nil
	delete(m.clearedFields, knowledgebase.FieldDocuments)
}

// SetMetadata sets the "metadata" field.
func (m *KnowledgeBaseMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *KnowledgeBaseMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the KnowledgeBase entity.
// If the KnowledgeBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeBaseMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *KnowledgeBaseMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[knowledgebase.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *KnowledgeBaseMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[knowledgebase.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *KnowledgeBaseMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, knowledgebase.FieldMetadata)
}

// SetCreatedBy sets the "created_by" field.
func (m *KnowledgeBaseMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *KnowledgeBaseMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the KnowledgeBase entity.
// If the KnowledgeBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeBaseMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *KnowledgeBaseMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *KnowledgeBaseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *KnowledgeBaseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the KnowledgeBase entity.
// If the KnowledgeBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeBaseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *KnowledgeBaseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *KnowledgeBaseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *KnowledgeBaseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the KnowledgeBase entity.
// If the KnowledgeBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeBaseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *KnowledgeBaseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDocumentCount sets the "document_count" field.
func (m *KnowledgeBaseMutation) SetDocumentCount(i int) {
	m.document_count = &i
	m.adddocument_count = nil
}

// DocumentCount returns the value of the "document_count" field in the mutation.
func (m *KnowledgeBaseMutation) DocumentCount() (r int, exists bool) {
	v := m.document_count
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentCount returns the old "document_count" field's value of the KnowledgeBase entity.
// If the KnowledgeBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeBaseMutation) OldDocumentCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentCount: %w", err)
	}
	return oldValue.DocumentCount, nil
}

// AddDocumentCount adds i to the "document_count" field.
func (m *KnowledgeBaseMutation) AddDocumentCount(i int) {
	if m.adddocument_count != nil {
		*m.adddocument_count += i
	} else {
		m.adddocument_count = &i
	}
}

// AddedDocumentCount returns the value that was added to the "document_count" field in this mutation.
func (m *KnowledgeBaseMutation) AddedDocumentCount() (r int, exists bool) {
	v := m.adddocument_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetDocumentCount resets all changes to the "document_count" field.
func (m *KnowledgeBaseMutation) ResetDocumentCount() {
	m.document_count = nil
	m.adddocument_count = nil
}

// SetVectorCount sets the "vector_count" field.
func (m *KnowledgeBaseMutation) SetVectorCount(i int) {
	m.vector_count = &i
	m.addvector_count = nil
}

// VectorCount returns the value of the "vector_count" field in the mutation.
func (m *KnowledgeBaseMutation) VectorCount() (r int, exists bool) {
	v := m.vector_count
	if v == nil {
		return
	}
	return *v, true
}

// OldVectorCount returns the old "vector_count" field's value of the KnowledgeBase entity.
// If the KnowledgeBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeBaseMutation) OldVectorCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVectorCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVectorCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVectorCount: %w", err)
	}
	return oldValue.VectorCount, nil
}

// AddVectorCount adds i to the "vector_count" field.
func (m *KnowledgeBaseMutation) AddVectorCount(i int) {
	if m.addvector_count != nil {
		*m.addvector_count += i
	} else {
		m.addvector_count = &i
	}
}

// AddedVectorCount returns the value that was added to the "vector_count" field in this mutation.
func (m *KnowledgeBaseMutation) AddedVectorCount() (r int, exists bool) {
	v := m.addvector_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetVectorCount resets all changes to the "vector_count" field.
func (m *KnowledgeBaseMutation) ResetVectorCount() {
	m.vector_count = nil
	m.addvector_count = nil
}

// Where appends a list predicates to the KnowledgeBaseMutation builder.
func (m *KnowledgeBaseMutation) Where(ps ...predicate.KnowledgeBase) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the KnowledgeBaseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *KnowledgeBaseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.KnowledgeBase, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *KnowledgeBaseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *KnowledgeBaseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (KnowledgeBase).
func (m *KnowledgeBaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KnowledgeBaseMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.name != nil {
		fields = append(fields, knowledgebase.FieldName)
	}
	if m.description != nil {
		fields = append(fields, knowledgebase.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, knowledgebase.FieldType)
	}
	if m.embedding_model != nil {
		fields = append(fields, knowledgebase.FieldEmbeddingModel)
	}
	if m.chunk_config != nil {
		fields = append(fields, knowledgebase.FieldChunkConfig)
	}
	if m.documents != nil {
		fields = append(fields, knowledgebase.FieldDocuments)
	}
	if m.metadata != nil {
		fields = append(fields, knowledgebase.FieldMetadata)
	}
	if m.created_by != nil {
		fields = append(fields, knowledgebase.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, knowledgebase.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, knowledgebase.FieldUpdatedAt)
	}
	if m.document_count != nil {
		fields = append(fields, knowledgebase.FieldDocumentCount)
	}
	if m.vector_count != nil {
		fields = append(fields, knowledgebase.FieldVectorCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KnowledgeBaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case knowledgebase.FieldName:
		return m.Name()
	case knowledgebase.FieldDescription:
		return m.Description()
	case knowledgebase.FieldType:
		return m.GetType()
	case knowledgebase.FieldEmbeddingModel:
		return m.EmbeddingModel()
	case knowledgebase.FieldChunkConfig:
		return m.ChunkConfig()
	case knowledgebase.FieldDocuments:
		return m.Documents()
	case knowledgebase.FieldMetadata:
		return m.Metadata()
	case knowledgebase.FieldCreatedBy:
		return m.CreatedBy()
	case knowledgebase.FieldCreatedAt:
		return m.CreatedAt()
	case knowledgebase.FieldUpdatedAt:
		return m.UpdatedAt()
	case knowledgebase.FieldDocumentCount:
		return m.DocumentCount()
	case knowledgebase.FieldVectorCount:
		return m.VectorCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KnowledgeBaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case knowledgebase.FieldName:
		return m.OldName(ctx)
	case knowledgebase.FieldDescription:
		return m.OldDescription(ctx)
	case knowledgebase.FieldType:
		return m.OldType(ctx)
	case knowledgebase.FieldEmbeddingModel:
		return m.OldEmbeddingModel(ctx)
	case knowledgebase.FieldChunkConfig:
		return m.OldChunkConfig(ctx)
	case knowledgebase.FieldDocuments:
		return m.OldDocuments(ctx)
	case knowledgebase.FieldMetadata:
		return m.OldMetadata(ctx)
	case knowledgebase.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case knowledgebase.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case knowledgebase.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case knowledgebase.FieldDocumentCount:
		return m.OldDocumentCount(ctx)
	case knowledgebase.FieldVectorCount:
		return m.OldVectorCount(ctx)
	}
	return nil, fmt.Errorf("unknown KnowledgeBase field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KnowledgeBaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case knowledgebase.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case knowledgebase.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case knowledgebase.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case knowledgebase.FieldEmbeddingModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmbeddingModel(v)
		return nil
	case knowledgebase.FieldChunkConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChunkConfig(v)
		return nil
	case knowledgebase.FieldDocuments:
		v, ok := value.([]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocuments(v)
		return nil
	case knowledgebase.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case knowledgebase.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case knowledgebase.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case knowledgebase.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case knowledgebase.FieldDocumentCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentCount(v)
		return nil
	case knowledgebase.FieldVectorCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVectorCount(v)
		return nil
	}
	return fmt.Errorf("unknown KnowledgeBase field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KnowledgeBaseMutation) AddedFields() []string {
	var fields []string
	if m.adddocument_count != nil {
		fields = append(fields, knowledgebase.FieldDocumentCount)
	}
	if m.addvector_count != nil {
		fields = append(fields, knowledgebase.FieldVectorCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KnowledgeBaseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case knowledgebase.FieldDocumentCount:
		return m.AddedDocumentCount()
	case knowledgebase.FieldVectorCount:
		return m.AddedVectorCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KnowledgeBaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case knowledgebase.FieldDocumentCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDocumentCount(v)
		return nil
	case knowledgebase.FieldVectorCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVectorCount(v)
		return nil
	}
	return fmt.Errorf("unknown KnowledgeBase numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KnowledgeBaseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(knowledgebase.FieldDescription) {
		fields = append(fields, knowledgebase.FieldDescription)
	}
	if m.FieldCleared(knowledgebase.FieldChunkConfig) {
		fields = append(fields, knowledgebase.FieldChunkConfig)
	}
	if m.FieldCleared(knowledgebase.FieldDocuments) {
		fields = append(fields, knowledgebase.FieldDocuments)
	}
	if m.FieldCleared(knowledgebase.FieldMetadata) {
		fields = append(fields, knowledgebase.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KnowledgeBaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KnowledgeBaseMutation) ClearField(name string) error {
	switch name {
	case knowledgebase.FieldDescription:
		m.ClearDescription()
		return nil
	case knowledgebase.FieldChunkConfig:
		m.ClearChunkConfig()
		return nil
	case knowledgebase.FieldDocuments:
		m.ClearDocuments()
		return nil
	case knowledgebase.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown KnowledgeBase nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KnowledgeBaseMutation) ResetField(name string) error {
	switch name {
	case knowledgebase.FieldName:
		m.ResetName()
		return nil
	case knowledgebase.FieldDescription:
		m.ResetDescription()
		return nil
	case knowledgebase.FieldType:
		m.ResetType()
		return nil
	case knowledgebase.FieldEmbeddingModel:
		m.ResetEmbeddingModel()
		return nil
	case knowledgebase.FieldChunkConfig:
		m.ResetChunkConfig()
		return nil
	case knowledgebase.FieldDocuments:
		m.ResetDocuments()
		return nil
	case knowledgebase.FieldMetadata:
		m.ResetMetadata()
		return nil
	case knowledgebase.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case knowledgebase.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case knowledgebase.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case knowledgebase.FieldDocumentCount:
		m.ResetDocumentCount()
		return nil
	case knowledgebase.FieldVectorCount:
		m.ResetVectorCount()
		return nil
	}
	return fmt.Errorf("unknown KnowledgeBase field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KnowledgeBaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KnowledgeBaseMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KnowledgeBaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KnowledgeBaseMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KnowledgeBaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KnowledgeBaseMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KnowledgeBaseMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown KnowledgeBase unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KnowledgeBaseMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown KnowledgeBase edge %s", name)
}

// ToolMutation represents an operation that mutates the Tool nodes in the graph.
type ToolMutation struct {
	config
	op             Op
	typ            string
	id             *string
	name           *string
	description    *string
	_type          *string
	schema         *map[string]interface{}
	implementation *string
	version        *string
	is_public      *bool
	created_by     *string
	created_at     *time.Time
	updated_at     *time.Time
	tags           *[]string
	appendtags     []string
	category       *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Tool, error)
	predicates     []predicate.Tool
}

var _ ent.Mutation = (*ToolMutation)(nil)

// toolOption allows management of the mutation configuration using functional options.
type toolOption func(*ToolMutation)

// newToolMutation creates new mutation for the Tool entity.
func newToolMutation(c config, op Op, opts ...toolOption) *ToolMutation {
	m := &ToolMutation{
		config:        c,
		op:            op,
		typ:           TypeTool,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withToolID sets the ID field of the mutation.
func withToolID(id string) toolOption {
	return func(m *ToolMutation) {
		var (
			err   error
			once  sync.Once
			value *Tool
		)
		m.oldValue = func(ctx context.Context) (*Tool, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tool.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTool sets the old Tool of the mutation.
func withTool(node *Tool) toolOption {
	return func(m *ToolMutation) {
		m.oldValue = func(context.Context) (*Tool, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ToolMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ToolMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tool entities.
func (m *ToolMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ToolMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ToolMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tool.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ToolMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ToolMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ToolMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ToolMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ToolMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ToolMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[tool.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ToolMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[tool.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ToolMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, tool.FieldDescription)
}

// SetType sets the "type" field.
func (m *ToolMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ToolMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ToolMutation) ResetType() {
	m._type = nil
}

// SetSchema sets the "schema" field.
func (m *ToolMutation) SetSchema(value map[string]interface{}) {
	m.schema = &value
}

// Schema returns the value of the "schema" field in the mutation.
func (m *ToolMutation) Schema() (r map[string]interface{}, exists bool) {
	v := m.schema
	if v == nil {
		return
	}
	return *v, true
}

// OldSchema returns the old "schema" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldSchema(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSchema is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSchema requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchema: %w", err)
	}
	return oldValue.Schema, nil
}

// ClearSchema clears the value of the "schema" field.
func (m *ToolMutation) ClearSchema() {
	m.schema = nil
	m.clearedFields[tool.FieldSchema] = struct{}{}
}

// SchemaCleared returns if the "schema" field was cleared in this mutation.
func (m *ToolMutation) SchemaCleared() bool {
	_, ok := m.clearedFields[tool.FieldSchema]
	return ok
}

// ResetSchema resets all changes to the "schema" field.
func (m *ToolMutation) ResetSchema() {
	m.schema = nil
	delete(m.clearedFields, tool.FieldSchema)
}

// SetImplementation sets the "implementation" field.
func (m *ToolMutation) SetImplementation(s string) {
	m.implementation = &s
}

// Implementation returns the value of the "implementation" field in the mutation.
func (m *ToolMutation) Implementation() (r string, exists bool) {
	v := m.implementation
	if v == nil {
		return
	}
	return *v, true
}

// OldImplementation returns the old "implementation" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldImplementation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImplementation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImplementation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImplementation: %w", err)
	}
	return oldValue.Implementation, nil
}

// ClearImplementation clears the value of the "implementation" field.
func (m *ToolMutation) ClearImplementation() {
	m.implementation = nil
	m.clearedFields[tool.FieldImplementation] = struct{}{}
}

// ImplementationCleared returns if the "implementation" field was cleared in this mutation.
func (m *ToolMutation) ImplementationCleared() bool {
	_, ok := m.clearedFields[tool.FieldImplementation]
	return ok
}

// ResetImplementation resets all changes to the "implementation" field.
func (m *ToolMutation) ResetImplementation() {
	m.implementation = nil
	delete(m.clearedFields, tool.FieldImplementation)
}

// SetVersion sets the "version" field.
func (m *ToolMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *ToolMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *ToolMutation) ResetVersion() {
	m.version = nil
}

// SetIsPublic sets the "is_public" field.
func (m *ToolMutation) SetIsPublic(b bool) {
	m.is_public = &b
}

// IsPublic returns the value of the "is_public" field in the mutation.
func (m *ToolMutation) IsPublic() (r bool, exists bool) {
	v := m.is_public
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublic returns the old "is_public" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldIsPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublic: %w", err)
	}
	return oldValue.IsPublic, nil
}

// ResetIsPublic resets all changes to the "is_public" field.
func (m *ToolMutation) ResetIsPublic() {
	m.is_public = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ToolMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ToolMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ToolMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ToolMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ToolMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ToolMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ToolMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ToolMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ToolMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTags sets the "tags" field.
func (m *ToolMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ToolMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ToolMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ToolMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ToolMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[tool.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ToolMutation) TagsCleared() bool {
	_, ok := m.clearedFields[tool.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ToolMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, tool.FieldTags)
}

// SetCategory sets the "category" field.
func (m *ToolMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ToolMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *ToolMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[tool.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *ToolMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[tool.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *ToolMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, tool.FieldCategory)
}

// Where appends a list predicates to the ToolMutation builder.
func (m *ToolMutation) Where(ps ...predicate.Tool) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ToolMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ToolMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tool, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ToolMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ToolMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tool).
func (m *ToolMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ToolMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.name != nil {
		fields = append(fields, tool.FieldName)
	}
	if m.description != nil {
		fields = append(fields, tool.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, tool.FieldType)
	}
	if m.schema != nil {
		fields = append(fields, tool.FieldSchema)
	}
	if m.implementation != nil {
		fields = append(fields, tool.FieldImplementation)
	}
	if m.version != nil {
		fields = append(fields, tool.FieldVersion)
	}
	if m.is_public != nil {
		fields = append(fields, tool.FieldIsPublic)
	}
	if m.created_by != nil {
		fields = append(fields, tool.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, tool.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tool.FieldUpdatedAt)
	}
	if m.tags != nil {
		fields = append(fields, tool.FieldTags)
	}
	if m.category != nil {
		fields = append(fields, tool.FieldCategory)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ToolMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tool.FieldName:
		return m.Name()
	case tool.FieldDescription:
		return m.Description()
	case tool.FieldType:
		return m.GetType()
	case tool.FieldSchema:
		return m.Schema()
	case tool.FieldImplementation:
		return m.Implementation()
	case tool.FieldVersion:
		return m.Version()
	case tool.FieldIsPublic:
		return m.IsPublic()
	case tool.FieldCreatedBy:
		return m.CreatedBy()
	case tool.FieldCreatedAt:
		return m.CreatedAt()
	case tool.FieldUpdatedAt:
		return m.UpdatedAt()
	case tool.FieldTags:
		return m.Tags()
	case tool.FieldCategory:
		return m.Category()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ToolMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tool.FieldName:
		return m.OldName(ctx)
	case tool.FieldDescription:
		return m.OldDescription(ctx)
	case tool.FieldType:
		return m.OldType(ctx)
	case tool.FieldSchema:
		return m.OldSchema(ctx)
	case tool.FieldImplementation:
		return m.OldImplementation(ctx)
	case tool.FieldVersion:
		return m.OldVersion(ctx)
	case tool.FieldIsPublic:
		return m.OldIsPublic(ctx)
	case tool.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case tool.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tool.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tool.FieldTags:
		return m.OldTags(ctx)
	case tool.FieldCategory:
		return m.OldCategory(ctx)
	}
	return nil, fmt.Errorf("unknown Tool field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ToolMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tool.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tool.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tool.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case tool.FieldSchema:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchema(v)
		return nil
	case tool.FieldImplementation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImplementation(v)
		return nil
	case tool.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case tool.FieldIsPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublic(v)
		return nil
	case tool.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case tool.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tool.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tool.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case tool.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	}
	return fmt.Errorf("unknown Tool field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ToolMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ToolMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ToolMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tool numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ToolMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tool.FieldDescription) {
		fields = append(fields, tool.FieldDescription)
	}
	if m.FieldCleared(tool.FieldSchema) {
		fields = append(fields, tool.FieldSchema)
	}
	if m.FieldCleared(tool.FieldImplementation) {
		fields = append(fields, tool.FieldImplementation)
	}
	if m.FieldCleared(tool.FieldTags) {
		fields = append(fields, tool.FieldTags)
	}
	if m.FieldCleared(tool.FieldCategory) {
		fields = append(fields, tool.FieldCategory)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ToolMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ToolMutation) ClearField(name string) error {
	switch name {
	case tool.FieldDescription:
		m.ClearDescription()
		return nil
	case tool.FieldSchema:
		m.ClearSchema()
		return nil
	case tool.FieldImplementation:
		m.ClearImplementation()
		return nil
	case tool.FieldTags:
		m.ClearTags()
		return nil
	case tool.FieldCategory:
		m.ClearCategory()
		return nil
	}
	return fmt.Errorf("unknown Tool nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ToolMutation) ResetField(name string) error {
	switch name {
	case tool.FieldName:
		m.ResetName()
		return nil
	case tool.FieldDescription:
		m.ResetDescription()
		return nil
	case tool.FieldType:
		m.ResetType()
		return nil
	case tool.FieldSchema:
		m.ResetSchema()
		return nil
	case tool.FieldImplementation:
		m.ResetImplementation()
		return nil
	case tool.FieldVersion:
		m.ResetVersion()
		return nil
	case tool.FieldIsPublic:
		m.ResetIsPublic()
		return nil
	case tool.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case tool.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tool.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tool.FieldTags:
		m.ResetTags()
		return nil
	case tool.FieldCategory:
		m.ResetCategory()
		return nil
	}
	return fmt.Errorf("unknown Tool field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ToolMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ToolMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ToolMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ToolMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ToolMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ToolMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ToolMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Tool unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ToolMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Tool edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *string
	username      *string
	email         *string
	password_hash *string
	role          *string
	status        *string
	metadata      *map[string]interface{}
	created_at    *time.Time
	updated_at    *time.Time
	last_login_at *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetMetadata sets the "metadata" field.
func (m *UserMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *UserMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *UserMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[user.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *UserMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[user.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *UserMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, user.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLastLoginAt sets the "last_login_at" field.
func (m *UserMutation) SetLastLoginAt(t time.Time) {
	m.last_login_at = &t
}

// LastLoginAt returns the value of the "last_login_at" field in the mutation.
func (m *UserMutation) LastLoginAt() (r time.Time, exists bool) {
	v := m.last_login_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginAt returns the old "last_login_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginAt: %w", err)
	}
	return oldValue.LastLoginAt, nil
}

// ClearLastLoginAt clears the value of the "last_login_at" field.
func (m *UserMutation) ClearLastLoginAt() {
	m.last_login_at = nil
	m.clearedFields[user.FieldLastLoginAt] = struct{}{}
}

// LastLoginAtCleared returns if the "last_login_at" field was cleared in this mutation.
func (m *UserMutation) LastLoginAtCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLoginAt]
	return ok
}

// ResetLastLoginAt resets all changes to the "last_login_at" field.
func (m *UserMutation) ResetLastLoginAt() {
	m.last_login_at = nil
	delete(m.clearedFields, user.FieldLastLoginAt)
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.metadata != nil {
		fields = append(fields, user.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.last_login_at != nil {
		fields = append(fields, user.FieldLastLoginAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldRole:
		return m.Role()
	case user.FieldStatus:
		return m.Status()
	case user.FieldMetadata:
		return m.Metadata()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldLastLoginAt:
		return m.LastLoginAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldMetadata:
		return m.OldMetadata(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldLastLoginAt:
		return m.OldLastLoginAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldLastLoginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldMetadata) {
		fields = append(fields, user.FieldMetadata)
	}
	if m.FieldCleared(user.FieldLastLoginAt) {
		fields = append(fields, user.FieldLastLoginAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldMetadata:
		m.ClearMetadata()
		return nil
	case user.FieldLastLoginAt:
		m.ClearLastLoginAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldMetadata:
		m.ResetMetadata()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldLastLoginAt:
		m.ResetLastLoginAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}

// WorkflowMutation represents an operation that mutates the Workflow nodes in the graph.
type WorkflowMutation struct {
	config
	op            Op
	typ           string
	id            *string
	name          *string
	description   *string
	steps         *[]map[string]interface{}
	appendsteps   []map[string]interface{}
	_config       *map[string]interface{}
	status        *string
	created_by    *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Workflow, error)
	predicates    []predicate.Workflow
}

var _ ent.Mutation = (*WorkflowMutation)(nil)

// workflowOption allows management of the mutation configuration using functional options.
type workflowOption func(*WorkflowMutation)

// newWorkflowMutation creates new mutation for the Workflow entity.
func newWorkflowMutation(c config, op Op, opts ...workflowOption) *WorkflowMutation {
	m := &WorkflowMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowID sets the ID field of the mutation.
func withWorkflowID(id string) workflowOption {
	return func(m *WorkflowMutation) {
		var (
			err   error
			once  sync.Once
			value *Workflow
		)
		m.oldValue = func(ctx context.Context) (*Workflow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Workflow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflow sets the old Workflow of the mutation.
func withWorkflow(node *Workflow) workflowOption {
	return func(m *WorkflowMutation) {
		m.oldValue = func(context.Context) (*Workflow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Workflow entities.
func (m *WorkflowMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Workflow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *WorkflowMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WorkflowMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WorkflowMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *WorkflowMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *WorkflowMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *WorkflowMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[workflow.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *WorkflowMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[workflow.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *WorkflowMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, workflow.FieldDescription)
}

// SetSteps sets the "steps" field.
func (m *WorkflowMutation) SetSteps(value []map[string]interface{}) {
	m.steps = &value
	m.appendsteps = nil
}

// Steps returns the value of the "steps" field in the mutation.
func (m *WorkflowMutation) Steps() (r []map[string]interface{}, exists bool) {
	v := m.steps
	if v == nil {
		return
	}
	return *v, true
}

// OldSteps returns the old "steps" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldSteps(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSteps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSteps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSteps: %w", err)
	}
	return oldValue.Steps, nil
}

// AppendSteps adds value to the "steps" field.
func (m *WorkflowMutation) AppendSteps(value []map[string]interface{}) {
	m.appendsteps = append(m.appendsteps, value...)
}

// AppendedSteps returns the list of values that were appended to the "steps" field in this mutation.
func (m *WorkflowMutation) AppendedSteps() ([]map[string]interface{}, bool) {
	if len(m.appendsteps) == 0 {
		return nil, false
	}
	return m.appendsteps, true
}

// ResetSteps resets all changes to the "steps" field.
func (m *WorkflowMutation) ResetSteps() {
	m.steps = nil
	m.appendsteps = nil
}

// SetConfig sets the "config" field.
func (m *WorkflowMutation) SetConfig(value map[string]interface{}) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *WorkflowMutation) Config() (r map[string]interface{}, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ClearConfig clears the value of the "config" field.
func (m *WorkflowMutation) ClearConfig() {
	m._config = nil
	m.clearedFields[workflow.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *WorkflowMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[workflow.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *WorkflowMutation) ResetConfig() {
	m._config = nil
	delete(m.clearedFields, workflow.FieldConfig)
}

// SetStatus sets the "status" field.
func (m *WorkflowMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *WorkflowMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *WorkflowMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *WorkflowMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *WorkflowMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *WorkflowMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkflowMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkflowMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkflowMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkflowMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkflowMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkflowMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the WorkflowMutation builder.
func (m *WorkflowMutation) Where(ps ...predicate.Workflow) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Workflow, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Workflow).
func (m *WorkflowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, workflow.FieldName)
	}
	if m.description != nil {
		fields = append(fields, workflow.FieldDescription)
	}
	if m.steps != nil {
		fields = append(fields, workflow.FieldSteps)
	}
	if m._config != nil {
		fields = append(fields, workflow.FieldConfig)
	}
	if m.status != nil {
		fields = append(fields, workflow.FieldStatus)
	}
	if m.created_by != nil {
		fields = append(fields, workflow.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, workflow.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workflow.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflow.FieldName:
		return m.Name()
	case workflow.FieldDescription:
		return m.Description()
	case workflow.FieldSteps:
		return m.Steps()
	case workflow.FieldConfig:
		return m.Config()
	case workflow.FieldStatus:
		return m.Status()
	case workflow.FieldCreatedBy:
		return m.CreatedBy()
	case workflow.FieldCreatedAt:
		return m.CreatedAt()
	case workflow.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflow.FieldName:
		return m.OldName(ctx)
	case workflow.FieldDescription:
		return m.OldDescription(ctx)
	case workflow.FieldSteps:
		return m.OldSteps(ctx)
	case workflow.FieldConfig:
		return m.OldConfig(ctx)
	case workflow.FieldStatus:
		return m.OldStatus(ctx)
	case workflow.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case workflow.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workflow.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Workflow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflow.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case workflow.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case workflow.FieldSteps:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSteps(v)
		return nil
	case workflow.FieldConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case workflow.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case workflow.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case workflow.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workflow.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Workflow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Workflow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflow.FieldDescription) {
		fields = append(fields, workflow.FieldDescription)
	}
	if m.FieldCleared(workflow.FieldConfig) {
		fields = append(fields, workflow.FieldConfig)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowMutation) ClearField(name string) error {
	switch name {
	case workflow.FieldDescription:
		m.ClearDescription()
		return nil
	case workflow.FieldConfig:
		m.ClearConfig()
		return nil
	}
	return fmt.Errorf("unknown Workflow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowMutation) ResetField(name string) error {
	switch name {
	case workflow.FieldName:
		m.ResetName()
		return nil
	case workflow.FieldDescription:
		m.ResetDescription()
		return nil
	case workflow.FieldSteps:
		m.ResetSteps()
		return nil
	case workflow.FieldConfig:
		m.ResetConfig()
		return nil
	case workflow.FieldStatus:
		m.ResetStatus()
		return nil
	case workflow.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case workflow.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workflow.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Workflow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Workflow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Workflow edge %s", name)
}

// WorkflowExecutionMutation represents an operation that mutates the WorkflowExecution nodes in the graph.
type WorkflowExecutionMutation struct {
	config
	op            Op
	typ           string
	id            *string
	workflow_id   *string
	input         *map[string]interface{}
	output        *map[string]interface{}
	context       *map[string]interface{}
	status        *string
	current_step  *string
	error         *string
	started_by    *string
	started_at    *time.Time
	completed_at  *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WorkflowExecution, error)
	predicates    []predicate.WorkflowExecution
}

var _ ent.Mutation = (*WorkflowExecutionMutation)(nil)

// workflowexecutionOption allows management of the mutation configuration using functional options.
type workflowexecutionOption func(*WorkflowExecutionMutation)

// newWorkflowExecutionMutation creates new mutation for the WorkflowExecution entity.
func newWorkflowExecutionMutation(c config, op Op, opts ...workflowexecutionOption) *WorkflowExecutionMutation {
	m := &WorkflowExecutionMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflowExecution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowExecutionID sets the ID field of the mutation.
func withWorkflowExecutionID(id string) workflowexecutionOption {
	return func(m *WorkflowExecutionMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkflowExecution
		)
		m.oldValue = func(ctx context.Context) (*WorkflowExecution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkflowExecution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflowExecution sets the old WorkflowExecution of the mutation.
func withWorkflowExecution(node *WorkflowExecution) workflowexecutionOption {
	return func(m *WorkflowExecutionMutation) {
		m.oldValue = func(context.Context) (*WorkflowExecution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowExecutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowExecutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkflowExecution entities.
func (m *WorkflowExecutionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowExecutionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowExecutionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkflowExecution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWorkflowID sets the "workflow_id" field.
func (m *WorkflowExecutionMutation) SetWorkflowID(s string) {
	m.workflow_id = &s
}

// WorkflowID returns the value of the "workflow_id" field in the mutation.
func (m *WorkflowExecutionMutation) WorkflowID() (r string, exists bool) {
	v := m.workflow_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowID returns the old "workflow_id" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldWorkflowID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowID: %w", err)
	}
	return oldValue.WorkflowID, nil
}

// ResetWorkflowID resets all changes to the "workflow_id" field.
func (m *WorkflowExecutionMutation) ResetWorkflowID() {
	m.workflow_id = nil
}

// SetInput sets the "input" field.
func (m *WorkflowExecutionMutation) SetInput(value map[string]interface{}) {
	m.input = &value
}

// Input returns the value of the "input" field in the mutation.
func (m *WorkflowExecutionMutation) Input() (r map[string]interface{}, exists bool) {
	v := m.input
	if v == nil {
		return
	}
	return *v, true
}

// OldInput returns the old "input" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldInput(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInput: %w", err)
	}
	return oldValue.Input, nil
}

// ClearInput clears the value of the "input" field.
func (m *WorkflowExecutionMutation) ClearInput() {
	m.input = nil
	m.clearedFields[workflowexecution.FieldInput] = struct{}{}
}

// InputCleared returns if the "input" field was cleared in this mutation.
func (m *WorkflowExecutionMutation) InputCleared() bool {
	_, ok := m.clearedFields[workflowexecution.FieldInput]
	return ok
}

// ResetInput resets all changes to the "input" field.
func (m *WorkflowExecutionMutation) ResetInput() {
	m.input = nil
	delete(m.clearedFields, workflowexecution.FieldInput)
}

// SetOutput sets the "output" field.
func (m *WorkflowExecutionMutation) SetOutput(value map[string]interface{}) {
	m.output = &value
}

// Output returns the value of the "output" field in the mutation.
func (m *WorkflowExecutionMutation) Output() (r map[string]interface{}, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldOutput(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// ClearOutput clears the value of the "output" field.
func (m *WorkflowExecutionMutation) ClearOutput() {
	m.output = nil
	m.clearedFields[workflowexecution.FieldOutput] = struct{}{}
}

// OutputCleared returns if the "output" field was cleared in this mutation.
func (m *WorkflowExecutionMutation) OutputCleared() bool {
	_, ok := m.clearedFields[workflowexecution.FieldOutput]
	return ok
}

// ResetOutput resets all changes to the "output" field.
func (m *WorkflowExecutionMutation) ResetOutput() {
	m.output = nil
	delete(m.clearedFields, workflowexecution.FieldOutput)
}

// SetContext sets the "context" field.
func (m *WorkflowExecutionMutation) SetContext(value map[string]interface{}) {
	m.context = &value
}

// Context returns the value of the "context" field in the mutation.
func (m *WorkflowExecutionMutation) Context() (r map[string]interface{}, exists bool) {
	v := m.context
	if v == nil {
		return
	}
	return *v, true
}

// OldContext returns the old "context" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldContext(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContext is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContext requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContext: %w", err)
	}
	return oldValue.Context, nil
}

// ClearContext clears the value of the "context" field.
func (m *WorkflowExecutionMutation) ClearContext() {
	m.context = nil
	m.clearedFields[workflowexecution.FieldContext] = struct{}{}
}

// ContextCleared returns if the "context" field was cleared in this mutation.
func (m *WorkflowExecutionMutation) ContextCleared() bool {
	_, ok := m.clearedFields[workflowexecution.FieldContext]
	return ok
}

// ResetContext resets all changes to the "context" field.
func (m *WorkflowExecutionMutation) ResetContext() {
	m.context = nil
	delete(m.clearedFields, workflowexecution.FieldContext)
}

// SetStatus sets the "status" field.
func (m *WorkflowExecutionMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *WorkflowExecutionMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *WorkflowExecutionMutation) ResetStatus() {
	m.status = nil
}

// SetCurrentStep sets the "current_step" field.
func (m *WorkflowExecutionMutation) SetCurrentStep(s string) {
	m.current_step = &s
}

// CurrentStep returns the value of the "current_step" field in the mutation.
func (m *WorkflowExecutionMutation) CurrentStep() (r string, exists bool) {
	v := m.current_step
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentStep returns the old "current_step" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldCurrentStep(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentStep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentStep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentStep: %w", err)
	}
	return oldValue.CurrentStep, nil
}

// ClearCurrentStep clears the value of the "current_step" field.
func (m *WorkflowExecutionMutation) ClearCurrentStep() {
	m.current_step = nil
	m.clearedFields[workflowexecution.FieldCurrentStep] = struct{}{}
}

// CurrentStepCleared returns if the "current_step" field was cleared in this mutation.
func (m *WorkflowExecutionMutation) CurrentStepCleared() bool {
	_, ok := m.clearedFields[workflowexecution.FieldCurrentStep]
	return ok
}

// ResetCurrentStep resets all changes to the "current_step" field.
func (m *WorkflowExecutionMutation) ResetCurrentStep() {
	m.current_step = nil
	delete(m.clearedFields, workflowexecution.FieldCurrentStep)
}

// SetError sets the "error" field.
func (m *WorkflowExecutionMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *WorkflowExecutionMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *WorkflowExecutionMutation) ClearError() {
	m.error = nil
	m.clearedFields[workflowexecution.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *WorkflowExecutionMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[workflowexecution.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *WorkflowExecutionMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, workflowexecution.FieldError)
}

// SetStartedBy sets the "started_by" field.
func (m *WorkflowExecutionMutation) SetStartedBy(s string) {
	m.started_by = &s
}

// StartedBy returns the value of the "started_by" field in the mutation.
func (m *WorkflowExecutionMutation) StartedBy() (r string, exists bool) {
	v := m.started_by
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedBy returns the old "started_by" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldStartedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedBy: %w", err)
	}
	return oldValue.StartedBy, nil
}

// ResetStartedBy resets all changes to the "started_by" field.
func (m *WorkflowExecutionMutation) ResetStartedBy() {
	m.started_by = nil
}

// SetStartedAt sets the "started_at" field.
func (m *WorkflowExecutionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *WorkflowExecutionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *WorkflowExecutionMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *WorkflowExecutionMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *WorkflowExecutionMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldCompletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *WorkflowExecutionMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[workflowexecution.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *WorkflowExecutionMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[workflowexecution.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *WorkflowExecutionMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, workflowexecution.FieldCompletedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkflowExecutionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkflowExecutionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WorkflowExecution entity.
// If the WorkflowExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowExecutionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkflowExecutionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the WorkflowExecutionMutation builder.
func (m *WorkflowExecutionMutation) Where(ps ...predicate.WorkflowExecution) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowExecutionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowExecutionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkflowExecution, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowExecutionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowExecutionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkflowExecution).
func (m *WorkflowExecutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowExecutionMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.workflow_id != nil {
		fields = append(fields, workflowexecution.FieldWorkflowID)
	}
	if m.input != nil {
		fields = append(fields, workflowexecution.FieldInput)
	}
	if m.output != nil {
		fields = append(fields, workflowexecution.FieldOutput)
	}
	if m.context != nil {
		fields = append(fields, workflowexecution.FieldContext)
	}
	if m.status != nil {
		fields = append(fields, workflowexecution.FieldStatus)
	}
	if m.current_step != nil {
		fields = append(fields, workflowexecution.FieldCurrentStep)
	}
	if m.error != nil {
		fields = append(fields, workflowexecution.FieldError)
	}
	if m.started_by != nil {
		fields = append(fields, workflowexecution.FieldStartedBy)
	}
	if m.started_at != nil {
		fields = append(fields, workflowexecution.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, workflowexecution.FieldCompletedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workflowexecution.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowExecutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflowexecution.FieldWorkflowID:
		return m.WorkflowID()
	case workflowexecution.FieldInput:
		return m.Input()
	case workflowexecution.FieldOutput:
		return m.Output()
	case workflowexecution.FieldContext:
		return m.Context()
	case workflowexecution.FieldStatus:
		return m.Status()
	case workflowexecution.FieldCurrentStep:
		return m.CurrentStep()
	case workflowexecution.FieldError:
		return m.Error()
	case workflowexecution.FieldStartedBy:
		return m.StartedBy()
	case workflowexecution.FieldStartedAt:
		return m.StartedAt()
	case workflowexecution.FieldCompletedAt:
		return m.CompletedAt()
	case workflowexecution.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowExecutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflowexecution.FieldWorkflowID:
		return m.OldWorkflowID(ctx)
	case workflowexecution.FieldInput:
		return m.OldInput(ctx)
	case workflowexecution.FieldOutput:
		return m.OldOutput(ctx)
	case workflowexecution.FieldContext:
		return m.OldContext(ctx)
	case workflowexecution.FieldStatus:
		return m.OldStatus(ctx)
	case workflowexecution.FieldCurrentStep:
		return m.OldCurrentStep(ctx)
	case workflowexecution.FieldError:
		return m.OldError(ctx)
	case workflowexecution.FieldStartedBy:
		return m.OldStartedBy(ctx)
	case workflowexecution.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case workflowexecution.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case workflowexecution.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown WorkflowExecution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowExecutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflowexecution.FieldWorkflowID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowID(v)
		return nil
	case workflowexecution.FieldInput:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInput(v)
		return nil
	case workflowexecution.FieldOutput:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case workflowexecution.FieldContext:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContext(v)
		return nil
	case workflowexecution.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case workflowexecution.FieldCurrentStep:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentStep(v)
		return nil
	case workflowexecution.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case workflowexecution.FieldStartedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedBy(v)
		return nil
	case workflowexecution.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case workflowexecution.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case workflowexecution.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowExecutionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowExecutionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowExecutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkflowExecution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowExecutionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflowexecution.FieldInput) {
		fields = append(fields, workflowexecution.FieldInput)
	}
	if m.FieldCleared(workflowexecution.FieldOutput) {
		fields = append(fields, workflowexecution.FieldOutput)
	}
	if m.FieldCleared(workflowexecution.FieldContext) {
		fields = append(fields, workflowexecution.FieldContext)
	}
	if m.FieldCleared(workflowexecution.FieldCurrentStep) {
		fields = append(fields, workflowexecution.FieldCurrentStep)
	}
	if m.FieldCleared(workflowexecution.FieldError) {
		fields = append(fields, workflowexecution.FieldError)
	}
	if m.FieldCleared(workflowexecution.FieldCompletedAt) {
		fields = append(fields, workflowexecution.FieldCompletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowExecutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowExecutionMutation) ClearField(name string) error {
	switch name {
	case workflowexecution.FieldInput:
		m.ClearInput()
		return nil
	case workflowexecution.FieldOutput:
		m.ClearOutput()
		return nil
	case workflowexecution.FieldContext:
		m.ClearContext()
		return nil
	case workflowexecution.FieldCurrentStep:
		m.ClearCurrentStep()
		return nil
	case workflowexecution.FieldError:
		m.ClearError()
		return nil
	case workflowexecution.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowExecutionMutation) ResetField(name string) error {
	switch name {
	case workflowexecution.FieldWorkflowID:
		m.ResetWorkflowID()
		return nil
	case workflowexecution.FieldInput:
		m.ResetInput()
		return nil
	case workflowexecution.FieldOutput:
		m.ResetOutput()
		return nil
	case workflowexecution.FieldContext:
		m.ResetContext()
		return nil
	case workflowexecution.FieldStatus:
		m.ResetStatus()
		return nil
	case workflowexecution.FieldCurrentStep:
		m.ResetCurrentStep()
		return nil
	case workflowexecution.FieldError:
		m.ResetError()
		return nil
	case workflowexecution.FieldStartedBy:
		m.ResetStartedBy()
		return nil
	case workflowexecution.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case workflowexecution.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case workflowexecution.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown WorkflowExecution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowExecutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowExecutionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowExecutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowExecutionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowExecutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowExecutionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowExecutionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WorkflowExecution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowExecutionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WorkflowExecution edge %s", name)
}
